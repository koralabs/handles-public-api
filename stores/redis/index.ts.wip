import {
    buildDrep,
    decodeAddress,
    getAddressHolderDetails,
    getPaymentKeyHash,
    HandlePaginationModel,
    HandleSearchModel,
    HolderAddressDetails,
    HolderPaginationModel,
    IHandlesProvider,
    IHandleStats,
    IHandleStoreMetrics,
    IUTxO,
    SaveMintingTxInput, SavePersonalizationInput,
    SaveSubHandleSettingsInput,
    SaveWalletAddressMoveInput,
    StoredHandle
} from '@koralabs/kora-labs-common';
import * as crypto from 'crypto';

export class RedisRepository implements IHandlesProvider{
    initialize: () => IHandlesProvider;
    getAll: (params: { pagination: HandlePaginationModel; search: HandleSearchModel; }) => Promise<{ searchTotal: number; handles: StoredHandle[]; }>;
    getHandlesByPaymentKeyHashes: (hashes: string[]) => string[];
    getHandlesByAddresses: (addresses: string[]) => string[];
    getHandlesByHolderAddresses: (addresses: string[]) => string[];
    getHandlesByStakeKeyHashes: (hashes: string[]) => string[];
    getAllHandleNames: (search: HandleSearchModel, sort: string) => Promise<string[]>;
    getHandleByName: (handleName: string) => Promise<StoredHandle | null>;
    getHandleByHex: (handleHex: string) => Promise<StoredHandle | null>;
    getHolderAddressDetails: (key: string) => Promise<HolderAddressDetails>;
    getAllHolders: (params: { pagination: HolderPaginationModel; }) => Promise<HolderAddressDetails[]>;
    getHandleStats: () => IHandleStats;
    getTotalHandlesStats: () => { total_handles: number; total_holders: number; };
    currentHttpStatus: () => number;
    getHandleDatumByName: (handleName: string) => Promise<string | null>;
    getSubHandleSettings: (handleName: string) => Promise<{ settings?: string; utxo: IUTxO; } | null>;
    getSubHandles: (handleName: string) => Promise<StoredHandle[]>;
    getTimeMetrics: () => { elapsedOgmiosExec: number; elapsedBuildingExec: number; };
    setMetrics: (metrics: IHandleStoreMetrics) => void;
    getMetrics: () => IHandleStats;
    prepareHandlesStorage: (loadS3: boolean) => Promise<{ slot: number; hash: string; } | null>;
    rollBackToGenesis: () => Promise<void>;
    isCaughtUp: () => boolean;
    burnHandle: (handleName: string, slotNumber: number) => Promise<void>;
    rewindChangesToSlot: ({ slot, hash, lastSlot }: { slot: number; hash: string; lastSlot: number; }) => Promise<{ name: string; action: string; handle: Partial<StoredHandle> | undefined; }[]>;
    savePersonalizationChange: ({ name, hex, personalization, reference_token, personalizationDatum, slotNumber, metadata }: SavePersonalizationInput) => Promise<void>;
    saveSubHandleSettingsChange: ({ name, settingsDatum, utxoDetails, slotNumber }: SaveSubHandleSettingsInput) => Promise<void>;
    saveMintedHandle: (input: SaveMintingTxInput) => Promise<void>;
    saveHandleUpdate: ({ name, adaAddress, utxo, slotNumber, datum, script }: SaveWalletAddressMoveInput) => Promise<void>;
    destroy: () => void;
    // Indexes

    private save = async ({ handle, oldHandle, saveHistory = true }: { handle: StoredHandle; oldHandle?: StoredHandle; saveHistory?: boolean }) => {
        const updatedHandle: StoredHandle = JSON.parse(JSON.stringify(handle, (k, v) => (typeof v === 'bigint' ? parseInt(v.toString() || '0') : v)));
        const {
            name,
            rarity,
            og_number,
            characters,
            numeric_modifiers,
            length,
            resolved_addresses: { ada },
            updated_slot_number
        } = updatedHandle;

        const holder = getAddressHolderDetails(ada);
        const payment_key_hash = (await getPaymentKeyHash(ada))!;
        updatedHandle.payment_key_hash = payment_key_hash;
        updatedHandle.drep = buildDrep(ada, updatedHandle.id_hash?.replace('0x', ''));
        updatedHandle.holder = updatedHandle.drep ? updatedHandle.drep.cip_129 : holder.address;
        updatedHandle.holder_type = updatedHandle.drep ? 'drep': holder.type;
        const handleDefault = handle.default;
        delete handle.default; // This is a temp property not meant to save to the handle

        // Set the main index
        this.handles.set(name, updatedHandle);
        this.redis.set(`handles-${name}`, JSON.stringify(updatedHandle))

        // Set default name during personalization
        this.setHolderIndex(holder, name, handleDefault, oldHandle?.holder);

        // set all one-to-many indexes
        this.addIndexSet(this.rarityIndex, rarity, name);

        const ogFlag = og_number === 0 ? 0 : 1;
        this.addIndexSet(this.ogIndex, `${ogFlag}`, name);
        this.addIndexSet(this.charactersIndex, characters, name);
        this.addIndexSet(this.paymentKeyHashesIndex, payment_key_hash, name);
        this.addIndexSet(this.numericModifiersIndex, numeric_modifiers, name);
        this.addIndexSet(this.lengthIndex, `${length}`, name);

        if (name.includes('@')) {
            const rootHandle = name.split('@')[1];
            this.addIndexSet(this.subHandlesIndex, rootHandle, name);
        }

        if (holder.address && holder.address != '') {
            // This could return null if it is a pre-Shelley address (not bech32)
            const decodedAddress = decodeAddress(holder.address);
            const oldDecodedAddress = decodeAddress(`${oldHandle?.holder}`);
            if (decodedAddress) {
                if (oldDecodedAddress) {
                    // if there is an old stake key hash, remove it from the index
                    const oldHashofStakeKeyHash = crypto.createHash('md5').update(oldDecodedAddress.slice(2), 'hex').digest('hex')
                    this.hashOfStakeKeyHashIndex.get(oldHashofStakeKeyHash)?.delete(name);                    
                }
                const hashofStakeKeyHash = crypto.createHash('md5').update(decodedAddress.slice(2), 'hex').digest('hex')
                this.addIndexSet(this.hashOfStakeKeyHashIndex, hashofStakeKeyHash, name);
            }
        }

        this.addressesIndex.get(oldHandle?.resolved_addresses.ada!)?.delete(name); 
        this.addIndexSet(this.addressesIndex, ada, name);

        // This is commented out for now as we might not need it since the history gets cleaned up on every call
        // const isWithinMaxSlot = this.metrics.lastSlot && this.metrics.currentSlot && this.metrics.lastSlot - this.metrics.currentSlot < this.twelveHourSlot;
        const isWithinMaxSlot = true;

        if (saveHistory && isWithinMaxSlot) {
            const history = HandleStore.buildHandleHistory(updatedHandle, oldHandle);
            if (history)
                HandleStore.saveSlotHistory({
                    handleHistory: history,
                    handleName: name,
                    slotNumber: updated_slot_number
                });
        }

    };
}

// #// webhook processor tracks block hash processed, only sends out webhook calls if not already processed
// #// webhook processor tracks rollback hashes, only sends out webhook calls if not already processed
// create: saveMintedHandle
// update: saveHandleUpdate or savePersonalizationChange (latter for pz-only)
// #// (any,pz-only,address-only,utxo-only,holder-only)
// #// use this to get if address/utxo change: diff(oldHandle, newHandle)
// #// Can exclude UTxO changes
// #// Can filter by list of handles/holders (up to 10?)
// delete: burnHandle

// rewind: rewindChangesToSlot
